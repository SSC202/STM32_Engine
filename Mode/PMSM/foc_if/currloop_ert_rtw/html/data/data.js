var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"IF/currloop","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"S:\\STM32SSC\\STM32\\STM32SSC_Engine\\Mode\\PMSM\\foc_if\\currloop_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'currloop'.\r\n *\r\n * Model version                  : 1.4\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Oct 28 19:50:01 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"currloop.h\"                  /* Model's header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(rtM, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  currloop_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example \"main\" function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific.  This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  currloop_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.0001 seconds (the model's base sample time) here.  The\r\n   * call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  /* Disable rt_OneStep here */\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"currloop.c","type":"source","group":"model","path":"S:\\STM32SSC\\STM32\\STM32SSC_Engine\\Mode\\PMSM\\foc_if\\currloop_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: currloop.c\r\n *\r\n * Code generated for Simulink model 'currloop'.\r\n *\r\n * Model version                  : 1.4\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Oct 28 19:50:01 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"currloop.h\"\r\n\r\n/* Named constants for Chart: '<S1>/State' */\r\n#define IN_AlignStage                  ((uint8_T)1U)\r\n#define IN_IDLE                        ((uint8_T)2U)\r\n#define IN_OpenStage                   ((uint8_T)3U)\r\n#define IN_RunStage                    ((uint8_T)4U)\r\n#define NumBitsPerChar                 8U\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n/* Skipping ulong_long/long_long check: insufficient preprocessor integer range. */\r\n\r\n/* Exported block signals */\r\nreal32_T ThetaOpen;                    /* '<S1>/Merge' */\r\nreal32_T id;                           /* '<S5>/Add' */\r\nreal32_T iq;                           /* '<S5>/Add1' */\r\n\r\n/* Exported data definition */\r\n\r\n/* Definition for custom storage class: Struct */\r\nmotor_type motor = {\r\n  /* Pn */\r\n  4.0F\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY rtY;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\nextern real32_T rt_modf_snf(real32_T u0, real32_T u1);\r\nstatic real_T rtGetNaN(void);\r\nstatic real32_T rtGetNaNF(void);\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nstatic void rt_InitInfAndNaN(size_t realSize);\r\nstatic boolean_T rtIsInf(real_T value);\r\nstatic boolean_T rtIsInfF(real32_T value);\r\nstatic boolean_T rtIsNaN(real_T value);\r\nstatic boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\nstatic real_T rtGetInf(void);\r\nstatic real32_T rtGetInfF(void);\r\nstatic real_T rtGetMinusInf(void);\r\nstatic real32_T rtGetMinusInfF(void);\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic void rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nstatic boolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nstatic boolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nstatic boolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nstatic boolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\nreal32_T rt_modf_snf(real32_T u0, real32_T u1)\r\n{\r\n  real32_T y;\r\n  y = u0;\r\n  if (u1 == 0.0F) {\r\n    if (u0 == 0.0F) {\r\n      y = u1;\r\n    }\r\n  } else if (rtIsNaNF(u0) || rtIsNaNF(u1) || rtIsInfF(u0)) {\r\n    y = (rtNaNF);\r\n  } else if (u0 == 0.0F) {\r\n    y = 0.0F / u1;\r\n  } else if (rtIsInfF(u1)) {\r\n    if ((u1 < 0.0F) != (u0 < 0.0F)) {\r\n      y = u1;\r\n    }\r\n  } else {\r\n    boolean_T yEq;\r\n    y = fmodf(u0, u1);\r\n    yEq = (y == 0.0F);\r\n    if ((!yEq) && (u1 > floorf(u1))) {\r\n      real32_T q;\r\n      q = fabsf(u0 / u1);\r\n      yEq = !(fabsf(q - floorf(q + 0.5F)) > FLT_EPSILON * q);\r\n    }\r\n\r\n    if (yEq) {\r\n      y = u1 * 0.0F;\r\n    } else if ((u0 < 0.0F) != (u1 < 0.0F)) {\r\n      y += u1;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid currloop_step(void)\r\n{\r\n  real_T rtb_Divide4;\r\n  real_T rtb_T4;\r\n  real_T rtb_T6;\r\n  real_T rtb_Tb;\r\n  real_T rtb_Tc_tmp_tmp;\r\n  real32_T rtb_Add1_p;\r\n  real32_T rtb_C;\r\n  real32_T rtb_DiscreteTimeIntegrator;\r\n  real32_T rtb_Gain1_p;\r\n  real32_T rtb_Integrator;\r\n  real32_T rtb_SignPreIntegrator;\r\n  real32_T rtb_SignPreSat;\r\n  real32_T rtb_Sum1_j;\r\n  int16_T rtb_IProdOut_d;\r\n  int16_T rtb_IProdOut_g;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/currloop' */\r\n  /* Sum: '<S3>/Add1' incorporates:\r\n   *  Gain: '<S3>/Gain'\r\n   *  Gain: '<S3>/Gain1'\r\n   *  Inport: '<Root>/ia'\r\n   *  Inport: '<Root>/ib'\r\n   *  Inport: '<Root>/ic'\r\n   *  Sum: '<S3>/Add'\r\n   */\r\n  rtb_Integrator = 0.666666687F * rtU.ia - (rtU.ib + rtU.ic) * 0.333333343F;\r\n\r\n  /* Chart: '<S1>/State' incorporates:\r\n   *  Inport: '<Root>/Motor_OnOff'\r\n   */\r\n  if (rtDW.temporalCounter_i1 < 32767U) {\r\n    rtDW.temporalCounter_i1++;\r\n  }\r\n\r\n  if (rtDW.is_active_c3_currloop == 0U) {\r\n    rtDW.is_active_c3_currloop = 1U;\r\n    rtDW.is_c3_currloop = IN_IDLE;\r\n  } else {\r\n    switch (rtDW.is_c3_currloop) {\r\n     case IN_AlignStage:\r\n      if (rtU.Motor_OnOff == 0.0) {\r\n        rtDW.is_c3_currloop = IN_IDLE;\r\n      } else if (rtDW.temporalCounter_i1 >= 1000) {\r\n        rtDW.is_c3_currloop = IN_OpenStage;\r\n        rtDW.temporalCounter_i1 = 0U;\r\n      } else {\r\n        rtDW.Motor_State = 2.0;\r\n      }\r\n      break;\r\n\r\n     case IN_IDLE:\r\n      if (rtU.Motor_OnOff == 1.0) {\r\n        rtDW.is_c3_currloop = IN_AlignStage;\r\n        rtDW.temporalCounter_i1 = 0U;\r\n      } else {\r\n        rtDW.Motor_State = 1.0;\r\n      }\r\n      break;\r\n\r\n     case IN_OpenStage:\r\n      if (rtU.Motor_OnOff == 0.0) {\r\n        rtDW.is_c3_currloop = IN_IDLE;\r\n      } else if (rtDW.temporalCounter_i1 >= 30000) {\r\n        rtDW.is_c3_currloop = IN_RunStage;\r\n      } else {\r\n        rtDW.Motor_State = 3.0;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_RunStage: */\r\n      if (rtU.Motor_OnOff == 0.0) {\r\n        rtDW.is_c3_currloop = IN_IDLE;\r\n      } else {\r\n        rtDW.Motor_State = 4.0;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S1>/State' */\r\n\r\n  /* SwitchCase: '<S1>/Switch Case' */\r\n  switch ((int32_T)rtDW.Motor_State) {\r\n   case 1:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem' incorporates:\r\n     *  ActionPort: '<S8>/Action Port'\r\n     */\r\n    /* Merge: '<S1>/Merge' incorporates:\r\n     *  Constant: '<S8>/Constant'\r\n     *  SignalConversion generated from: '<S8>/theta_feedback'\r\n     */\r\n    ThetaOpen = 0.0F;\r\n\r\n    /* Merge: '<S1>/Merge1' incorporates:\r\n     *  Constant: '<S8>/Constant1'\r\n     *  SignalConversion generated from: '<S8>/iq_ref'\r\n     */\r\n    rtDW.Merge1 = 0.0F;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem' */\r\n    break;\r\n\r\n   case 2:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem1' incorporates:\r\n     *  ActionPort: '<S9>/Action Port'\r\n     */\r\n    /* Merge: '<S1>/Merge' incorporates:\r\n     *  Constant: '<S9>/Constant'\r\n     *  SignalConversion generated from: '<S9>/theta_feedback'\r\n     */\r\n    ThetaOpen = 0.0F;\r\n\r\n    /* Merge: '<S1>/Merge1' incorporates:\r\n     *  Constant: '<S9>/Constant1'\r\n     *  SignalConversion generated from: '<S9>/iq_ref'\r\n     */\r\n    rtDW.Merge1 = 1.0F;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem1' */\r\n    break;\r\n\r\n   case 3:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem3' incorporates:\r\n     *  ActionPort: '<S11>/Action Port'\r\n     */\r\n    /* DiscreteIntegrator: '<S16>/Discrete-Time Integrator' */\r\n    rtb_DiscreteTimeIntegrator = rtDW.DiscreteTimeIntegrator_DSTATE_l;\r\n\r\n    /* Merge: '<S1>/Merge' incorporates:\r\n     *  Constant: '<S16>/Constant1'\r\n     *  DiscreteIntegrator: '<S16>/Discrete-Time Integrator1'\r\n     *  Math: '<S16>/Mod'\r\n     */\r\n    ThetaOpen = rt_modf_snf(rtDW.DiscreteTimeIntegrator1_DSTATE, 6.28318548F);\r\n\r\n    /* Merge: '<S1>/Merge1' incorporates:\r\n     *  Constant: '<S1>/Constant5'\r\n     *  Inport: '<S11>/iq_ref'\r\n     */\r\n    rtDW.Merge1 = 1.0F;\r\n\r\n    /* Update for DiscreteIntegrator: '<S16>/Discrete-Time Integrator' incorporates:\r\n     *  Gain: '<S16>/Gain1'\r\n     *  Product: '<S16>/Product'\r\n     */\r\n    rtDW.DiscreteTimeIntegrator_DSTATE_l += motor.Pn * 83.7758F * 0.333333343F *\r\n      0.0001F;\r\n\r\n    /* Update for DiscreteIntegrator: '<S16>/Discrete-Time Integrator1' */\r\n    rtDW.DiscreteTimeIntegrator1_DSTATE += 0.0001F * rtb_DiscreteTimeIntegrator;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem3' */\r\n    break;\r\n\r\n   case 4:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem2' incorporates:\r\n     *  ActionPort: '<S10>/Action Port'\r\n     */\r\n    /* Merge: '<S1>/Merge' incorporates:\r\n     *  Constant: '<S10>/Constant1'\r\n     *  DiscreteIntegrator: '<S10>/Discrete-Time Integrator'\r\n     *  Math: '<S10>/Mod'\r\n     */\r\n    ThetaOpen = rt_modf_snf(rtDW.DiscreteTimeIntegrator_DSTATE, 6.28318548F);\r\n\r\n    /* Merge: '<S1>/Merge1' incorporates:\r\n     *  Constant: '<S1>/Constant7'\r\n     *  Inport: '<S10>/iq_ref'\r\n     */\r\n    rtDW.Merge1 = 1.0F;\r\n\r\n    /* Update for DiscreteIntegrator: '<S10>/Discrete-Time Integrator' incorporates:\r\n     *  Gain: '<S10>/Gain1'\r\n     */\r\n    rtDW.DiscreteTimeIntegrator_DSTATE += motor.Pn * 83.7758F * 0.0001F;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem2' */\r\n    break;\r\n  }\r\n\r\n  /* End of SwitchCase: '<S1>/Switch Case' */\r\n\r\n  /* Trigonometry: '<S1>/SinCos1' */\r\n  rtb_C = cosf(ThetaOpen);\r\n\r\n  /* Gain: '<S3>/Gain2' incorporates:\r\n   *  Inport: '<Root>/ib'\r\n   *  Inport: '<Root>/ic'\r\n   *  Sum: '<S3>/Add2'\r\n   */\r\n  rtb_DiscreteTimeIntegrator = (rtU.ib - rtU.ic) * 0.577350259F;\r\n\r\n  /* Trigonometry: '<S1>/SinCos' */\r\n  rtb_Sum1_j = sinf(ThetaOpen);\r\n\r\n  /* Sum: '<S5>/Add' incorporates:\r\n   *  Product: '<S5>/Product'\r\n   *  Product: '<S5>/Product1'\r\n   */\r\n  id = rtb_Integrator * rtb_C + rtb_DiscreteTimeIntegrator * rtb_Sum1_j;\r\n\r\n  /* Sum: '<S61>/Sum' incorporates:\r\n   *  Constant: '<S12>/Constant'\r\n   *  Constant: '<S12>/Constant3'\r\n   *  DiscreteIntegrator: '<S52>/Integrator'\r\n   *  Product: '<S57>/PProd Out'\r\n   *  Sum: '<S12>/Sum1'\r\n   */\r\n  rtb_SignPreSat = (0.0F - id) * 0.17F + (real32_T)rtDW.Integrator_DSTATE_n *\r\n    0.0001F;\r\n\r\n  /* Saturate: '<S59>/Saturation' */\r\n  if (rtb_SignPreSat > 12.4707661F) {\r\n    rtb_Gain1_p = 12.4707661F;\r\n  } else if (rtb_SignPreSat < -12.4707661F) {\r\n    rtb_Gain1_p = -12.4707661F;\r\n  } else {\r\n    rtb_Gain1_p = rtb_SignPreSat;\r\n  }\r\n\r\n  /* End of Saturate: '<S59>/Saturation' */\r\n\r\n  /* Sum: '<S5>/Add1' incorporates:\r\n   *  Product: '<S5>/Product2'\r\n   *  Product: '<S5>/Product3'\r\n   */\r\n  iq = rtb_DiscreteTimeIntegrator * rtb_C - rtb_Integrator * rtb_Sum1_j;\r\n\r\n  /* Sum: '<S12>/Sum7' */\r\n  rtb_DiscreteTimeIntegrator = rtDW.Merge1 - iq;\r\n\r\n  /* Sum: '<S111>/Sum' incorporates:\r\n   *  Constant: '<S12>/Constant1'\r\n   *  DiscreteIntegrator: '<S102>/Integrator'\r\n   *  Product: '<S107>/PProd Out'\r\n   */\r\n  rtb_Integrator = rtb_DiscreteTimeIntegrator * 0.17F + rtDW.Integrator_DSTATE;\r\n\r\n  /* Saturate: '<S109>/Saturation' */\r\n  if (rtb_Integrator > 12.4707661F) {\r\n    rtb_Add1_p = 12.4707661F;\r\n  } else if (rtb_Integrator < -12.4707661F) {\r\n    rtb_Add1_p = -12.4707661F;\r\n  } else {\r\n    rtb_Add1_p = rtb_Integrator;\r\n  }\r\n\r\n  /* End of Saturate: '<S109>/Saturation' */\r\n\r\n  /* Sum: '<S2>/Add' incorporates:\r\n   *  Product: '<S2>/Product'\r\n   *  Product: '<S2>/Product1'\r\n   */\r\n  rtb_SignPreIntegrator = rtb_Gain1_p * rtb_C - rtb_Add1_p * rtb_Sum1_j;\r\n\r\n  /* Sum: '<S2>/Add1' incorporates:\r\n   *  Product: '<S2>/Product2'\r\n   *  Product: '<S2>/Product3'\r\n   */\r\n  rtb_Add1_p = rtb_Gain1_p * rtb_Sum1_j + rtb_Add1_p * rtb_C;\r\n\r\n  /* Gain: '<S13>/Gain1' incorporates:\r\n   *  Gain: '<S14>/Gain2'\r\n   */\r\n  rtb_Gain1_p = 0.866025388F * rtb_SignPreIntegrator;\r\n\r\n  /* Gain: '<S13>/Gain2' incorporates:\r\n   *  Gain: '<S14>/Gain1'\r\n   */\r\n  rtb_Sum1_j = 0.5F * rtb_Add1_p;\r\n\r\n  /* Sum: '<S13>/Add' incorporates:\r\n   *  Gain: '<S13>/Gain1'\r\n   *  Gain: '<S13>/Gain2'\r\n   *  Gain: '<S13>/Gain3'\r\n   *  Gain: '<S13>/Gain4'\r\n   *  Gain: '<S13>/Gain5'\r\n   *  Sum: '<S13>/Sum'\r\n   *  Sum: '<S13>/Sum1'\r\n   *  Switch: '<S13>/Switch'\r\n   *  Switch: '<S13>/Switch1'\r\n   *  Switch: '<S13>/Switch2'\r\n   */\r\n  rtb_C = (real32_T)((((-rtb_Gain1_p - rtb_Sum1_j > 0.0F) << 2) + ((rtb_Gain1_p\r\n    - rtb_Sum1_j > 0.0F) << 1)) + (rtb_Add1_p > 0.0F));\r\n\r\n  /* Product: '<S14>/Divide' incorporates:\r\n   *  Inport: '<Root>/u_bus'\r\n   */\r\n  rtb_T6 = 1.7320508075688772 / rtU.u_bus;\r\n\r\n  /* MultiPortSwitch: '<S14>/Multiport Switch' incorporates:\r\n   *  Gain: '<S14>/Gain3'\r\n   *  Gain: '<S14>/Gain4'\r\n   *  Gain: '<S14>/Gain5'\r\n   *  Gain: '<S14>/Gain6'\r\n   *  Product: '<S14>/Divide1'\r\n   *  Product: '<S14>/Divide2'\r\n   *  Product: '<S14>/Divide3'\r\n   *  Sum: '<S14>/Sum'\r\n   *  Sum: '<S14>/Sum1'\r\n   */\r\n  switch ((int32_T)rtb_C) {\r\n   case 1:\r\n    rtb_T4 = (-rtb_Gain1_p + rtb_Sum1_j) * rtb_T6;\r\n\r\n    /* MultiPortSwitch: '<S14>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S14>/Gain3'\r\n     *  Product: '<S14>/Divide2'\r\n     *  Product: '<S14>/Divide3'\r\n     *  Sum: '<S14>/Sum'\r\n     *  Sum: '<S14>/Sum1'\r\n     */\r\n    rtb_T6 *= rtb_Gain1_p + rtb_Sum1_j;\r\n    break;\r\n\r\n   case 2:\r\n    rtb_T4 = (rtb_Gain1_p + rtb_Sum1_j) * rtb_T6;\r\n\r\n    /* MultiPortSwitch: '<S14>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S14>/Gain6'\r\n     *  Product: '<S14>/Divide1'\r\n     *  Product: '<S14>/Divide2'\r\n     *  Sum: '<S14>/Sum'\r\n     */\r\n    rtb_T6 = -(rtb_Add1_p * rtb_T6);\r\n    break;\r\n\r\n   case 3:\r\n    rtb_T4 = -((-rtb_Gain1_p + rtb_Sum1_j) * rtb_T6);\r\n\r\n    /* MultiPortSwitch: '<S14>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S14>/Gain3'\r\n     *  Gain: '<S14>/Gain4'\r\n     *  Product: '<S14>/Divide1'\r\n     *  Product: '<S14>/Divide3'\r\n     *  Sum: '<S14>/Sum1'\r\n     */\r\n    rtb_T6 *= rtb_Add1_p;\r\n    break;\r\n\r\n   case 4:\r\n    rtb_T4 = -(rtb_Add1_p * rtb_T6);\r\n\r\n    /* MultiPortSwitch: '<S14>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S14>/Gain3'\r\n     *  Gain: '<S14>/Gain6'\r\n     *  Product: '<S14>/Divide1'\r\n     *  Product: '<S14>/Divide3'\r\n     *  Sum: '<S14>/Sum1'\r\n     */\r\n    rtb_T6 *= -rtb_Gain1_p + rtb_Sum1_j;\r\n    break;\r\n\r\n   case 5:\r\n    rtb_T4 = rtb_Add1_p * rtb_T6;\r\n\r\n    /* MultiPortSwitch: '<S14>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S14>/Gain5'\r\n     *  Product: '<S14>/Divide1'\r\n     *  Product: '<S14>/Divide2'\r\n     *  Sum: '<S14>/Sum'\r\n     */\r\n    rtb_T6 = -((rtb_Gain1_p + rtb_Sum1_j) * rtb_T6);\r\n    break;\r\n\r\n   default:\r\n    rtb_T4 = -((rtb_Gain1_p + rtb_Sum1_j) * rtb_T6);\r\n\r\n    /* MultiPortSwitch: '<S14>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S14>/Gain3'\r\n     *  Gain: '<S14>/Gain4'\r\n     *  Gain: '<S14>/Gain5'\r\n     *  Product: '<S14>/Divide2'\r\n     *  Product: '<S14>/Divide3'\r\n     *  Sum: '<S14>/Sum'\r\n     *  Sum: '<S14>/Sum1'\r\n     */\r\n    rtb_T6 = -((-rtb_Gain1_p + rtb_Sum1_j) * rtb_T6);\r\n    break;\r\n  }\r\n\r\n  /* End of MultiPortSwitch: '<S14>/Multiport Switch' */\r\n\r\n  /* Product: '<S14>/Divide4' incorporates:\r\n   *  Sum: '<S14>/Subtract'\r\n   */\r\n  rtb_Divide4 = 1.0 / (rtb_T4 + rtb_T6);\r\n\r\n  /* Switch: '<S14>/Switch' incorporates:\r\n   *  Constant: '<S1>/Constant1'\r\n   *  Product: '<S14>/Divide5'\r\n   *  Product: '<S14>/Divide6'\r\n   *  Sum: '<S14>/Add'\r\n   *  Switch: '<S14>/Switch1'\r\n   */\r\n  if ((rtb_T4 - 1.0) + rtb_T6 > 0.0) {\r\n    rtb_T4 *= rtb_Divide4;\r\n    rtb_T6 *= rtb_Divide4;\r\n  }\r\n\r\n  /* End of Switch: '<S14>/Switch' */\r\n\r\n  /* Gain: '<S15>/Gain' incorporates:\r\n   *  Constant: '<S1>/Constant1'\r\n   *  Sum: '<S15>/Add'\r\n   */\r\n  rtb_Divide4 = ((1.0 - rtb_T4) - rtb_T6) * 0.25;\r\n\r\n  /* Sum: '<S15>/Add1' incorporates:\r\n   *  Gain: '<S15>/Gain1'\r\n   */\r\n  rtb_Tb = 0.5 * rtb_T4 + rtb_Divide4;\r\n\r\n  /* Sum: '<S15>/Add2' incorporates:\r\n   *  Gain: '<S15>/Gain2'\r\n   */\r\n  rtb_Tc_tmp_tmp = 0.5 * rtb_T6 + rtb_Tb;\r\n\r\n  /* MultiPortSwitch: '<S15>/Tcm1 ' incorporates:\r\n   *  Gain: '<S15>/Gain2'\r\n   *  Sum: '<S15>/Add2'\r\n   */\r\n  switch ((int32_T)rtb_C) {\r\n   case 1:\r\n    rtb_T4 = rtb_Tb;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm2' */\r\n    rtb_T6 = rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm3' incorporates:\r\n     *  Sum: '<S15>/Add2'\r\n     */\r\n    rtb_Divide4 = rtb_Tc_tmp_tmp;\r\n    break;\r\n\r\n   case 2:\r\n    rtb_T4 = rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm2' incorporates:\r\n     *  Gain: '<S15>/Gain2'\r\n     *  Sum: '<S15>/Add2'\r\n     */\r\n    rtb_T6 = 0.5 * rtb_T6 + rtb_Tb;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm3' */\r\n    rtb_Divide4 = rtb_Tb;\r\n    break;\r\n\r\n   case 3:\r\n    rtb_T4 = rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm2' */\r\n    rtb_T6 = rtb_Tb;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm3' incorporates:\r\n     *  Sum: '<S15>/Add2'\r\n     */\r\n    rtb_Divide4 = rtb_Tc_tmp_tmp;\r\n    break;\r\n\r\n   case 4:\r\n    rtb_T4 = 0.5 * rtb_T6 + rtb_Tb;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm2' incorporates:\r\n     *  Gain: '<S15>/Gain2'\r\n     *  Sum: '<S15>/Add2'\r\n     */\r\n    rtb_T6 = rtb_Tb;\r\n    break;\r\n\r\n   case 5:\r\n    rtb_T4 = 0.5 * rtb_T6 + rtb_Tb;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm2' incorporates:\r\n     *  Gain: '<S15>/Gain2'\r\n     *  Sum: '<S15>/Add2'\r\n     */\r\n    rtb_T6 = rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm3' */\r\n    rtb_Divide4 = rtb_Tb;\r\n    break;\r\n\r\n   default:\r\n    rtb_T4 = rtb_Tb;\r\n\r\n    /* MultiPortSwitch: '<S15>/Tcm2' incorporates:\r\n     *  Gain: '<S15>/Gain2'\r\n     *  Sum: '<S15>/Add2'\r\n     */\r\n    rtb_T6 = 0.5 * rtb_T6 + rtb_Tb;\r\n    break;\r\n  }\r\n\r\n  /* End of MultiPortSwitch: '<S15>/Tcm1 ' */\r\n\r\n  /* Gain: '<S43>/ZeroGain' */\r\n  rtb_Gain1_p = 0.0F * rtb_SignPreSat;\r\n\r\n  /* DeadZone: '<S45>/DeadZone' */\r\n  if (rtb_SignPreSat > 12.4707661F) {\r\n    rtb_SignPreSat -= 12.4707661F;\r\n  } else if (rtb_SignPreSat >= -12.4707661F) {\r\n    rtb_SignPreSat = 0.0F;\r\n  } else {\r\n    rtb_SignPreSat -= -12.4707661F;\r\n  }\r\n\r\n  /* End of DeadZone: '<S45>/DeadZone' */\r\n\r\n  /* Product: '<S49>/IProd Out' incorporates:\r\n   *  Constant: '<S12>/Constant'\r\n   *  Constant: '<S12>/Constant4'\r\n   *  Sum: '<S12>/Sum1'\r\n   */\r\n  rtb_IProdOut_g = (int16_T)floorf((0.0F - id) * 35.0F);\r\n\r\n  /* Gain: '<S93>/ZeroGain' */\r\n  rtb_C = 0.0F * rtb_Integrator;\r\n\r\n  /* DeadZone: '<S95>/DeadZone' */\r\n  if (rtb_Integrator > 12.4707661F) {\r\n    rtb_Integrator -= 12.4707661F;\r\n  } else if (rtb_Integrator >= -12.4707661F) {\r\n    rtb_Integrator = 0.0F;\r\n  } else {\r\n    rtb_Integrator -= -12.4707661F;\r\n  }\r\n\r\n  /* End of DeadZone: '<S95>/DeadZone' */\r\n\r\n  /* Product: '<S99>/IProd Out' incorporates:\r\n   *  Constant: '<S12>/Constant2'\r\n   */\r\n  rtb_DiscreteTimeIntegrator *= 35.0F;\r\n\r\n  /* Signum: '<S43>/SignPreSat' */\r\n  if (rtb_SignPreSat < 0.0F) {\r\n    rtb_Add1_p = -1.0F;\r\n  } else if (rtb_SignPreSat > 0.0F) {\r\n    rtb_Add1_p = 1.0F;\r\n  } else if (rtb_SignPreSat == 0.0F) {\r\n    rtb_Add1_p = 0.0F;\r\n  } else {\r\n    rtb_Add1_p = (rtNaNF);\r\n  }\r\n\r\n  /* End of Signum: '<S43>/SignPreSat' */\r\n\r\n  /* Signum: '<S43>/SignPreIntegrator' */\r\n  if (rtb_IProdOut_g < 0) {\r\n    rtb_IProdOut_d = -1;\r\n  } else {\r\n    rtb_IProdOut_d = (int16_T)(rtb_IProdOut_g > 0);\r\n  }\r\n\r\n  /* End of Signum: '<S43>/SignPreIntegrator' */\r\n\r\n  /* Switch: '<S43>/Switch' incorporates:\r\n   *  Constant: '<S43>/Constant1'\r\n   *  DataTypeConversion: '<S43>/DataTypeConv1'\r\n   *  DataTypeConversion: '<S43>/DataTypeConv2'\r\n   *  Logic: '<S43>/AND3'\r\n   *  RelationalOperator: '<S43>/Equal1'\r\n   *  RelationalOperator: '<S43>/NotEqual'\r\n   */\r\n  if ((rtb_Gain1_p != rtb_SignPreSat) && ((int8_T)rtb_Add1_p == rtb_IProdOut_d))\r\n  {\r\n    rtb_IProdOut_g = 0;\r\n  }\r\n\r\n  /* End of Switch: '<S43>/Switch' */\r\n\r\n  /* Update for DiscreteIntegrator: '<S52>/Integrator' */\r\n  rtDW.Integrator_DSTATE_n += rtb_IProdOut_g;\r\n\r\n  /* Signum: '<S93>/SignPreSat' */\r\n  if (rtb_Integrator < 0.0F) {\r\n    rtb_SignPreSat = -1.0F;\r\n  } else if (rtb_Integrator > 0.0F) {\r\n    rtb_SignPreSat = 1.0F;\r\n  } else if (rtb_Integrator == 0.0F) {\r\n    rtb_SignPreSat = 0.0F;\r\n  } else {\r\n    rtb_SignPreSat = (rtNaNF);\r\n  }\r\n\r\n  /* End of Signum: '<S93>/SignPreSat' */\r\n\r\n  /* Signum: '<S93>/SignPreIntegrator' */\r\n  if (rtb_DiscreteTimeIntegrator < 0.0F) {\r\n    rtb_Gain1_p = -1.0F;\r\n  } else if (rtb_DiscreteTimeIntegrator > 0.0F) {\r\n    rtb_Gain1_p = 1.0F;\r\n  } else if (rtb_DiscreteTimeIntegrator == 0.0F) {\r\n    rtb_Gain1_p = 0.0F;\r\n  } else {\r\n    rtb_Gain1_p = (rtNaNF);\r\n  }\r\n\r\n  /* End of Signum: '<S93>/SignPreIntegrator' */\r\n\r\n  /* Switch: '<S93>/Switch' incorporates:\r\n   *  Constant: '<S93>/Constant1'\r\n   *  DataTypeConversion: '<S93>/DataTypeConv1'\r\n   *  DataTypeConversion: '<S93>/DataTypeConv2'\r\n   *  Logic: '<S93>/AND3'\r\n   *  RelationalOperator: '<S93>/Equal1'\r\n   *  RelationalOperator: '<S93>/NotEqual'\r\n   */\r\n  if ((rtb_C != rtb_Integrator) && ((int8_T)rtb_SignPreSat == (int8_T)\r\n       rtb_Gain1_p)) {\r\n    rtb_DiscreteTimeIntegrator = 0.0F;\r\n  }\r\n\r\n  /* End of Switch: '<S93>/Switch' */\r\n\r\n  /* Update for DiscreteIntegrator: '<S102>/Integrator' */\r\n  rtDW.Integrator_DSTATE += 0.0001F * rtb_DiscreteTimeIntegrator;\r\n\r\n  /* Outport: '<Root>/Dutyout' incorporates:\r\n   *  Constant: '<S1>/Constant1'\r\n   *  Gain: '<S4>/Gain'\r\n   *  Sum: '<S4>/Add'\r\n   *  Sum: '<S4>/Add1'\r\n   *  Sum: '<S4>/Add2'\r\n   */\r\n  rtY.Dutyout[0] = 1.0 - 2.0 * rtb_T4;\r\n  rtY.Dutyout[1] = 1.0 - 2.0 * rtb_T6;\r\n  rtY.Dutyout[2] = 1.0 - 2.0 * rtb_Divide4;\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/currloop' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid currloop_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"currloop.h","type":"header","group":"model","path":"S:\\STM32SSC\\STM32\\STM32SSC_Engine\\Mode\\PMSM\\foc_if\\currloop_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: currloop.h\r\n *\r\n * Code generated for Simulink model 'currloop'.\r\n *\r\n * Model version                  : 1.4\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Oct 28 19:50:01 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_currloop_h_\r\n#define RTW_HEADER_currloop_h_\r\n#include <stddef.h>\r\n#include <float.h>\r\n#include <math.h>\r\n#ifndef currloop_COMMON_INCLUDES_\r\n#define currloop_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* currloop_COMMON_INCLUDES_ */\r\n\r\n/* Model Code Variants */\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T Motor_State;                  /* '<S1>/State' */\r\n  real32_T Merge1;                     /* '<S1>/Merge1' */\r\n  real32_T Integrator_DSTATE;          /* '<S102>/Integrator' */\r\n  real32_T DiscreteTimeIntegrator_DSTATE;/* '<S10>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator_DSTATE_l;/* '<S16>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator1_DSTATE;/* '<S16>/Discrete-Time Integrator1' */\r\n  int16_T Integrator_DSTATE_n;         /* '<S52>/Integrator' */\r\n  uint16_T temporalCounter_i1;         /* '<S1>/State' */\r\n  uint8_T is_active_c3_currloop;       /* '<S1>/State' */\r\n  uint8_T is_c3_currloop;              /* '<S1>/State' */\r\n} DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real32_T ia;                         /* '<Root>/ia' */\r\n  real32_T ib;                         /* '<Root>/ib' */\r\n  real32_T ic;                         /* '<Root>/ic' */\r\n  real32_T u_bus;                      /* '<Root>/u_bus' */\r\n  real_T Motor_OnOff;                  /* '<Root>/Motor_OnOff' */\r\n} ExtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T Dutyout[3];                   /* '<Root>/Dutyout' */\r\n} ExtY;\r\n\r\n/* Type definition for custom storage class: Struct */\r\ntypedef struct motor_tag {\r\n  real32_T Pn;                         /* Referenced by:\r\n                                        * '<S10>/Gain1'\r\n                                        * '<S16>/Gain1'\r\n                                        */\r\n} motor_type;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY rtY;\r\n\r\n/*\r\n * Exported Global Signals\r\n *\r\n * Note: Exported global signals are block signals with an exported global\r\n * storage class designation.  Code generation will declare the memory for\r\n * these signals and export their symbols.\r\n *\r\n */\r\nextern real32_T ThetaOpen;             /* '<S1>/Merge' */\r\nextern real32_T id;                    /* '<S5>/Add' */\r\nextern real32_T iq;                    /* '<S5>/Add1' */\r\n\r\n/* Model entry point functions */\r\nextern void currloop_initialize(void);\r\nextern void currloop_step(void);\r\n\r\n/* Exported data declaration */\r\n\r\n/* Declaration for custom storage class: Struct */\r\nextern motor_type motor;\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S13>/Scope' : Unused code path elimination\r\n * Block '<S13>/Scope1' : Unused code path elimination\r\n * Block '<S14>/Scope' : Unused code path elimination\r\n * Block '<S1>/Scope' : Unused code path elimination\r\n * Block '<S12>/Scope' : Unused code path elimination\r\n * Block '<S1>/Data Type Conversion3' : Eliminate redundant data type conversion\r\n * Block '<S1>/Data Type Conversion4' : Eliminate redundant data type conversion\r\n * Block '<S13>/Gain' : Eliminated nontunable gain of 1\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('IF/currloop')    - opens subsystem IF/currloop\r\n * hilite_system('IF/currloop/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'IF'\r\n * '<S1>'   : 'IF/currloop'\r\n * '<S2>'   : 'IF/currloop/AntiPark'\r\n * '<S3>'   : 'IF/currloop/Clark'\r\n * '<S4>'   : 'IF/currloop/PWMOut'\r\n * '<S5>'   : 'IF/currloop/Park'\r\n * '<S6>'   : 'IF/currloop/SVPWM'\r\n * '<S7>'   : 'IF/currloop/State'\r\n * '<S8>'   : 'IF/currloop/Switch Case Action Subsystem'\r\n * '<S9>'   : 'IF/currloop/Switch Case Action Subsystem1'\r\n * '<S10>'  : 'IF/currloop/Switch Case Action Subsystem2'\r\n * '<S11>'  : 'IF/currloop/Switch Case Action Subsystem3'\r\n * '<S12>'  : 'IF/currloop/idq_Controller'\r\n * '<S13>'  : 'IF/currloop/SVPWM/N'\r\n * '<S14>'  : 'IF/currloop/SVPWM/t4_t6'\r\n * '<S15>'  : 'IF/currloop/SVPWM/t_abc'\r\n * '<S16>'  : 'IF/currloop/Switch Case Action Subsystem3/Theta_generate'\r\n * '<S17>'  : 'IF/currloop/idq_Controller/PID Controller1'\r\n * '<S18>'  : 'IF/currloop/idq_Controller/PID Controller2'\r\n * '<S19>'  : 'IF/currloop/idq_Controller/PID Controller1/Anti-windup'\r\n * '<S20>'  : 'IF/currloop/idq_Controller/PID Controller1/D Gain'\r\n * '<S21>'  : 'IF/currloop/idq_Controller/PID Controller1/Filter'\r\n * '<S22>'  : 'IF/currloop/idq_Controller/PID Controller1/Filter ICs'\r\n * '<S23>'  : 'IF/currloop/idq_Controller/PID Controller1/I Gain'\r\n * '<S24>'  : 'IF/currloop/idq_Controller/PID Controller1/Ideal P Gain'\r\n * '<S25>'  : 'IF/currloop/idq_Controller/PID Controller1/Ideal P Gain Fdbk'\r\n * '<S26>'  : 'IF/currloop/idq_Controller/PID Controller1/Integrator'\r\n * '<S27>'  : 'IF/currloop/idq_Controller/PID Controller1/Integrator ICs'\r\n * '<S28>'  : 'IF/currloop/idq_Controller/PID Controller1/N Copy'\r\n * '<S29>'  : 'IF/currloop/idq_Controller/PID Controller1/N Gain'\r\n * '<S30>'  : 'IF/currloop/idq_Controller/PID Controller1/P Copy'\r\n * '<S31>'  : 'IF/currloop/idq_Controller/PID Controller1/Parallel P Gain'\r\n * '<S32>'  : 'IF/currloop/idq_Controller/PID Controller1/Reset Signal'\r\n * '<S33>'  : 'IF/currloop/idq_Controller/PID Controller1/Saturation'\r\n * '<S34>'  : 'IF/currloop/idq_Controller/PID Controller1/Saturation Fdbk'\r\n * '<S35>'  : 'IF/currloop/idq_Controller/PID Controller1/Sum'\r\n * '<S36>'  : 'IF/currloop/idq_Controller/PID Controller1/Sum Fdbk'\r\n * '<S37>'  : 'IF/currloop/idq_Controller/PID Controller1/Tracking Mode'\r\n * '<S38>'  : 'IF/currloop/idq_Controller/PID Controller1/Tracking Mode Sum'\r\n * '<S39>'  : 'IF/currloop/idq_Controller/PID Controller1/Tsamp - Integral'\r\n * '<S40>'  : 'IF/currloop/idq_Controller/PID Controller1/Tsamp - Ngain'\r\n * '<S41>'  : 'IF/currloop/idq_Controller/PID Controller1/postSat Signal'\r\n * '<S42>'  : 'IF/currloop/idq_Controller/PID Controller1/preSat Signal'\r\n * '<S43>'  : 'IF/currloop/idq_Controller/PID Controller1/Anti-windup/Disc. Clamping Parallel'\r\n * '<S44>'  : 'IF/currloop/idq_Controller/PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S45>'  : 'IF/currloop/idq_Controller/PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S46>'  : 'IF/currloop/idq_Controller/PID Controller1/D Gain/Disabled'\r\n * '<S47>'  : 'IF/currloop/idq_Controller/PID Controller1/Filter/Disabled'\r\n * '<S48>'  : 'IF/currloop/idq_Controller/PID Controller1/Filter ICs/Disabled'\r\n * '<S49>'  : 'IF/currloop/idq_Controller/PID Controller1/I Gain/External Parameters'\r\n * '<S50>'  : 'IF/currloop/idq_Controller/PID Controller1/Ideal P Gain/Passthrough'\r\n * '<S51>'  : 'IF/currloop/idq_Controller/PID Controller1/Ideal P Gain Fdbk/Disabled'\r\n * '<S52>'  : 'IF/currloop/idq_Controller/PID Controller1/Integrator/Discrete'\r\n * '<S53>'  : 'IF/currloop/idq_Controller/PID Controller1/Integrator ICs/Internal IC'\r\n * '<S54>'  : 'IF/currloop/idq_Controller/PID Controller1/N Copy/Disabled wSignal Specification'\r\n * '<S55>'  : 'IF/currloop/idq_Controller/PID Controller1/N Gain/Disabled'\r\n * '<S56>'  : 'IF/currloop/idq_Controller/PID Controller1/P Copy/Disabled'\r\n * '<S57>'  : 'IF/currloop/idq_Controller/PID Controller1/Parallel P Gain/External Parameters'\r\n * '<S58>'  : 'IF/currloop/idq_Controller/PID Controller1/Reset Signal/Disabled'\r\n * '<S59>'  : 'IF/currloop/idq_Controller/PID Controller1/Saturation/Enabled'\r\n * '<S60>'  : 'IF/currloop/idq_Controller/PID Controller1/Saturation Fdbk/Disabled'\r\n * '<S61>'  : 'IF/currloop/idq_Controller/PID Controller1/Sum/Sum_PI'\r\n * '<S62>'  : 'IF/currloop/idq_Controller/PID Controller1/Sum Fdbk/Disabled'\r\n * '<S63>'  : 'IF/currloop/idq_Controller/PID Controller1/Tracking Mode/Disabled'\r\n * '<S64>'  : 'IF/currloop/idq_Controller/PID Controller1/Tracking Mode Sum/Passthrough'\r\n * '<S65>'  : 'IF/currloop/idq_Controller/PID Controller1/Tsamp - Integral/Passthrough'\r\n * '<S66>'  : 'IF/currloop/idq_Controller/PID Controller1/Tsamp - Ngain/Passthrough'\r\n * '<S67>'  : 'IF/currloop/idq_Controller/PID Controller1/postSat Signal/Forward_Path'\r\n * '<S68>'  : 'IF/currloop/idq_Controller/PID Controller1/preSat Signal/Forward_Path'\r\n * '<S69>'  : 'IF/currloop/idq_Controller/PID Controller2/Anti-windup'\r\n * '<S70>'  : 'IF/currloop/idq_Controller/PID Controller2/D Gain'\r\n * '<S71>'  : 'IF/currloop/idq_Controller/PID Controller2/Filter'\r\n * '<S72>'  : 'IF/currloop/idq_Controller/PID Controller2/Filter ICs'\r\n * '<S73>'  : 'IF/currloop/idq_Controller/PID Controller2/I Gain'\r\n * '<S74>'  : 'IF/currloop/idq_Controller/PID Controller2/Ideal P Gain'\r\n * '<S75>'  : 'IF/currloop/idq_Controller/PID Controller2/Ideal P Gain Fdbk'\r\n * '<S76>'  : 'IF/currloop/idq_Controller/PID Controller2/Integrator'\r\n * '<S77>'  : 'IF/currloop/idq_Controller/PID Controller2/Integrator ICs'\r\n * '<S78>'  : 'IF/currloop/idq_Controller/PID Controller2/N Copy'\r\n * '<S79>'  : 'IF/currloop/idq_Controller/PID Controller2/N Gain'\r\n * '<S80>'  : 'IF/currloop/idq_Controller/PID Controller2/P Copy'\r\n * '<S81>'  : 'IF/currloop/idq_Controller/PID Controller2/Parallel P Gain'\r\n * '<S82>'  : 'IF/currloop/idq_Controller/PID Controller2/Reset Signal'\r\n * '<S83>'  : 'IF/currloop/idq_Controller/PID Controller2/Saturation'\r\n * '<S84>'  : 'IF/currloop/idq_Controller/PID Controller2/Saturation Fdbk'\r\n * '<S85>'  : 'IF/currloop/idq_Controller/PID Controller2/Sum'\r\n * '<S86>'  : 'IF/currloop/idq_Controller/PID Controller2/Sum Fdbk'\r\n * '<S87>'  : 'IF/currloop/idq_Controller/PID Controller2/Tracking Mode'\r\n * '<S88>'  : 'IF/currloop/idq_Controller/PID Controller2/Tracking Mode Sum'\r\n * '<S89>'  : 'IF/currloop/idq_Controller/PID Controller2/Tsamp - Integral'\r\n * '<S90>'  : 'IF/currloop/idq_Controller/PID Controller2/Tsamp - Ngain'\r\n * '<S91>'  : 'IF/currloop/idq_Controller/PID Controller2/postSat Signal'\r\n * '<S92>'  : 'IF/currloop/idq_Controller/PID Controller2/preSat Signal'\r\n * '<S93>'  : 'IF/currloop/idq_Controller/PID Controller2/Anti-windup/Disc. Clamping Parallel'\r\n * '<S94>'  : 'IF/currloop/idq_Controller/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S95>'  : 'IF/currloop/idq_Controller/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S96>'  : 'IF/currloop/idq_Controller/PID Controller2/D Gain/Disabled'\r\n * '<S97>'  : 'IF/currloop/idq_Controller/PID Controller2/Filter/Disabled'\r\n * '<S98>'  : 'IF/currloop/idq_Controller/PID Controller2/Filter ICs/Disabled'\r\n * '<S99>'  : 'IF/currloop/idq_Controller/PID Controller2/I Gain/External Parameters'\r\n * '<S100>' : 'IF/currloop/idq_Controller/PID Controller2/Ideal P Gain/Passthrough'\r\n * '<S101>' : 'IF/currloop/idq_Controller/PID Controller2/Ideal P Gain Fdbk/Disabled'\r\n * '<S102>' : 'IF/currloop/idq_Controller/PID Controller2/Integrator/Discrete'\r\n * '<S103>' : 'IF/currloop/idq_Controller/PID Controller2/Integrator ICs/Internal IC'\r\n * '<S104>' : 'IF/currloop/idq_Controller/PID Controller2/N Copy/Disabled wSignal Specification'\r\n * '<S105>' : 'IF/currloop/idq_Controller/PID Controller2/N Gain/Disabled'\r\n * '<S106>' : 'IF/currloop/idq_Controller/PID Controller2/P Copy/Disabled'\r\n * '<S107>' : 'IF/currloop/idq_Controller/PID Controller2/Parallel P Gain/External Parameters'\r\n * '<S108>' : 'IF/currloop/idq_Controller/PID Controller2/Reset Signal/Disabled'\r\n * '<S109>' : 'IF/currloop/idq_Controller/PID Controller2/Saturation/Enabled'\r\n * '<S110>' : 'IF/currloop/idq_Controller/PID Controller2/Saturation Fdbk/Disabled'\r\n * '<S111>' : 'IF/currloop/idq_Controller/PID Controller2/Sum/Sum_PI'\r\n * '<S112>' : 'IF/currloop/idq_Controller/PID Controller2/Sum Fdbk/Disabled'\r\n * '<S113>' : 'IF/currloop/idq_Controller/PID Controller2/Tracking Mode/Disabled'\r\n * '<S114>' : 'IF/currloop/idq_Controller/PID Controller2/Tracking Mode Sum/Passthrough'\r\n * '<S115>' : 'IF/currloop/idq_Controller/PID Controller2/Tsamp - Integral/Passthrough'\r\n * '<S116>' : 'IF/currloop/idq_Controller/PID Controller2/Tsamp - Ngain/Passthrough'\r\n * '<S117>' : 'IF/currloop/idq_Controller/PID Controller2/postSat Signal/Forward_Path'\r\n * '<S118>' : 'IF/currloop/idq_Controller/PID Controller2/preSat Signal/Forward_Path'\r\n */\r\n#endif                                 /* RTW_HEADER_currloop_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"S:\\STM32SSC\\STM32\\STM32SSC_Engine\\Mode\\PMSM\\foc_if\\currloop_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'currloop'.\r\n *\r\n * Model version                  : 1.4\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Oct 28 19:50:01 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex-M\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};