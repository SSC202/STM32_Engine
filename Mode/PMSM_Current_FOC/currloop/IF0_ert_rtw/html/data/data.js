var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"currloop/IF","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"S:\\STM32SSC\\STM32\\STM32SSC_Engine\\Mode\\PMSM\\currloop\\IF0_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'IF0'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon Dec 18 15:46:35 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"IF0.h\"                       /* Model's header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(rtM, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  IF0_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example \"main\" function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific.  This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  IF0_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.0001 seconds (the model's base sample time) here.  The\r\n   * call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  /* Disable rt_OneStep here */\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"IF0.c","type":"source","group":"model","path":"S:\\STM32SSC\\STM32\\STM32SSC_Engine\\Mode\\PMSM\\currloop\\IF0_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: IF0.c\r\n *\r\n * Code generated for Simulink model 'IF0'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon Dec 18 15:46:35 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"IF0.h\"\r\n\r\n/* Named constants for Chart: '<S1>/Chart' */\r\n#define IN_AlignStage                  ((uint8_T)1U)\r\n#define IN_IDLE                        ((uint8_T)2U)\r\n#define IN_OpenStage                   ((uint8_T)3U)\r\n#define IN_RunStage                    ((uint8_T)4U)\r\n#define NumBitsPerChar                 8U\r\n\r\n/* Exported data definition */\r\n\r\n/* Definition for custom storage class: Struct */\r\nMotor_type Motor = {\r\n  /* Pn */\r\n  4.0F\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY rtY;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\nextern real_T rt_modd_snf(real_T u0, real_T u1);\r\nstatic real_T rtGetNaN(void);\r\nstatic real32_T rtGetNaNF(void);\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nstatic void rt_InitInfAndNaN(size_t realSize);\r\nstatic boolean_T rtIsInf(real_T value);\r\nstatic boolean_T rtIsInfF(real32_T value);\r\nstatic boolean_T rtIsNaN(real_T value);\r\nstatic boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\nstatic real_T rtGetInf(void);\r\nstatic real32_T rtGetInfF(void);\r\nstatic real_T rtGetMinusInf(void);\r\nstatic real32_T rtGetMinusInfF(void);\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic void rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nstatic boolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nstatic boolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nstatic boolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nstatic boolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nstatic real32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\nreal_T rt_modd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  y = u0;\r\n  if (u1 == 0.0) {\r\n    if (u0 == 0.0) {\r\n      y = u1;\r\n    }\r\n  } else if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (u0 == 0.0) {\r\n    y = 0.0 / u1;\r\n  } else if (rtIsInf(u1)) {\r\n    if ((u1 < 0.0) != (u0 < 0.0)) {\r\n      y = u1;\r\n    }\r\n  } else {\r\n    boolean_T yEq;\r\n    y = fmod(u0, u1);\r\n    yEq = (y == 0.0);\r\n    if ((!yEq) && (u1 > floor(u1))) {\r\n      real_T q;\r\n      q = fabs(u0 / u1);\r\n      yEq = !(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q);\r\n    }\r\n\r\n    if (yEq) {\r\n      y = u1 * 0.0;\r\n    } else if ((u0 < 0.0) != (u1 < 0.0)) {\r\n      y += u1;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid IF0_step(void)\r\n{\r\n  real_T rtb_DiscreteTimeIntegrator;\r\n  real_T rtb_Divide4;\r\n  real_T rtb_Divide4_tmp;\r\n  real_T rtb_IProdOut_a;\r\n  real_T rtb_Saturation;\r\n  real_T rtb_SignPreSat;\r\n  real_T rtb_SignPreSat_e;\r\n  real_T rtb_Subtract;\r\n  real_T rtb_T4;\r\n  real_T rtb_T6;\r\n  real_T rtb_ZeroGain_f;\r\n  real32_T rtb_A;\r\n  real32_T rtb_Add2_c;\r\n  real32_T rtb_Gain2_n;\r\n  real32_T rtb_SinCos2;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/IF' */\r\n  /* Sum: '<S4>/Add2' incorporates:\r\n   *  Gain: '<S4>/Gain'\r\n   *  Gain: '<S4>/Gain1'\r\n   *  Inport: '<Root>/ia'\r\n   *  Inport: '<Root>/ib'\r\n   *  Inport: '<Root>/ic'\r\n   *  Sum: '<S4>/Add'\r\n   */\r\n  rtb_Add2_c = 0.666666687F * rtU.ia - (rtU.ib + rtU.ic) * 0.333333343F;\r\n\r\n  /* Chart: '<S1>/Chart' incorporates:\r\n   *  Inport: '<Root>/Motor_OnOff'\r\n   */\r\n  if (rtDW.temporalCounter_i1 < 32767U) {\r\n    rtDW.temporalCounter_i1++;\r\n  }\r\n\r\n  if (rtDW.is_active_c3_IF0 == 0U) {\r\n    rtDW.is_active_c3_IF0 = 1U;\r\n    rtDW.is_c3_IF0 = IN_IDLE;\r\n  } else {\r\n    switch (rtDW.is_c3_IF0) {\r\n     case IN_AlignStage:\r\n      if (rtDW.temporalCounter_i1 >= 1000) {\r\n        rtDW.is_c3_IF0 = IN_OpenStage;\r\n        rtDW.temporalCounter_i1 = 0U;\r\n      } else if (rtU.Motor_OnOff == 0.0) {\r\n        rtDW.is_c3_IF0 = IN_IDLE;\r\n      } else {\r\n        rtDW.Motor_State = 2.0;\r\n      }\r\n      break;\r\n\r\n     case IN_IDLE:\r\n      if (rtU.Motor_OnOff == 1.0) {\r\n        rtDW.is_c3_IF0 = IN_AlignStage;\r\n        rtDW.temporalCounter_i1 = 0U;\r\n      } else {\r\n        rtDW.Motor_State = 1.0;\r\n      }\r\n      break;\r\n\r\n     case IN_OpenStage:\r\n      if (rtDW.temporalCounter_i1 >= 30000) {\r\n        rtDW.is_c3_IF0 = IN_RunStage;\r\n      } else if (rtU.Motor_OnOff == 0.0) {\r\n        rtDW.is_c3_IF0 = IN_IDLE;\r\n      } else {\r\n        rtDW.Motor_State = 3.0;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_RunStage: */\r\n      if (rtU.Motor_OnOff == 0.0) {\r\n        rtDW.is_c3_IF0 = IN_IDLE;\r\n      } else {\r\n        rtDW.Motor_State = 4.0;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S1>/Chart' */\r\n\r\n  /* SwitchCase: '<S1>/Switch Case' */\r\n  switch ((int32_T)rtDW.Motor_State) {\r\n   case 1:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem' incorporates:\r\n     *  ActionPort: '<S9>/Action Port'\r\n     */\r\n    /* Merge: '<S1>/Merge' incorporates:\r\n     *  Constant: '<S9>/Constant'\r\n     *  SignalConversion generated from: '<S9>/theta_fdb'\r\n     */\r\n    rtDW.Merge = 0.0;\r\n\r\n    /* Merge: '<S1>/Merge1' incorporates:\r\n     *  Constant: '<S9>/Constant1'\r\n     *  SignalConversion generated from: '<S9>/iq_ref'\r\n     */\r\n    rtDW.Merge1 = 0.0;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem' */\r\n    break;\r\n\r\n   case 2:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem1' incorporates:\r\n     *  ActionPort: '<S10>/Action Port'\r\n     */\r\n    /* Merge: '<S1>/Merge' incorporates:\r\n     *  Constant: '<S10>/Constant'\r\n     *  SignalConversion generated from: '<S10>/theta_fdb'\r\n     */\r\n    rtDW.Merge = 0.0;\r\n\r\n    /* Merge: '<S1>/Merge1' incorporates:\r\n     *  Constant: '<S10>/Constant1'\r\n     *  SignalConversion generated from: '<S10>/iq_ref'\r\n     */\r\n    rtDW.Merge1 = 1.0;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem1' */\r\n    break;\r\n\r\n   case 3:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem2' incorporates:\r\n     *  ActionPort: '<S11>/Action Port'\r\n     */\r\n    /* DiscreteIntegrator: '<S11>/Discrete-Time Integrator' */\r\n    rtb_DiscreteTimeIntegrator = rtDW.DiscreteTimeIntegrator_DSTATE;\r\n\r\n    /* Merge: '<S1>/Merge' incorporates:\r\n     *  Constant: '<S11>/Constant1'\r\n     *  DiscreteIntegrator: '<S11>/Discrete-Time Integrator1'\r\n     *  Math: '<S11>/Mod'\r\n     */\r\n    rtDW.Merge = rt_modd_snf(rtDW.DiscreteTimeIntegrator1_DSTAT_h,\r\n      6.2831853071795862);\r\n\r\n    /* Merge: '<S1>/Merge1' incorporates:\r\n     *  Constant: '<S1>/Constant6'\r\n     *  Inport: '<S11>/iq_ref'\r\n     */\r\n    rtDW.Merge1 = 1.0;\r\n\r\n    /* Update for DiscreteIntegrator: '<S11>/Discrete-Time Integrator' incorporates:\r\n     *  Gain: '<S11>/Gain1'\r\n     *  Product: '<S11>/Product'\r\n     */\r\n    rtDW.DiscreteTimeIntegrator_DSTATE += Motor.Pn * 83.7758040957278 *\r\n      0.33333333333333331 * 0.0001;\r\n\r\n    /* Update for DiscreteIntegrator: '<S11>/Discrete-Time Integrator1' */\r\n    rtDW.DiscreteTimeIntegrator1_DSTAT_h += 0.0001 * rtb_DiscreteTimeIntegrator;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem2' */\r\n    break;\r\n\r\n   case 4:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem3' incorporates:\r\n     *  ActionPort: '<S12>/Action Port'\r\n     */\r\n    /* Merge: '<S1>/Merge' incorporates:\r\n     *  Constant: '<S12>/Constant1'\r\n     *  DiscreteIntegrator: '<S12>/Discrete-Time Integrator1'\r\n     *  Math: '<S12>/Mod'\r\n     */\r\n    rtDW.Merge = rt_modd_snf(rtDW.DiscreteTimeIntegrator1_DSTATE,\r\n      6.2831853071795862);\r\n\r\n    /* Merge: '<S1>/Merge1' incorporates:\r\n     *  Constant: '<S1>/Constant7'\r\n     *  Inport: '<S12>/iq_ref'\r\n     */\r\n    rtDW.Merge1 = 1.0;\r\n\r\n    /* Update for DiscreteIntegrator: '<S12>/Discrete-Time Integrator1' incorporates:\r\n     *  Gain: '<S12>/Gain1'\r\n     */\r\n    rtDW.DiscreteTimeIntegrator1_DSTATE += Motor.Pn * 83.7758040957278 * 0.0001;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem3' */\r\n    break;\r\n  }\r\n\r\n  /* End of SwitchCase: '<S1>/Switch Case' */\r\n\r\n  /* Trigonometry: '<S1>/SinCos2' incorporates:\r\n   *  DataTypeConversion: '<S1>/Data Type Conversion4'\r\n   */\r\n  rtb_SinCos2 = cosf((real32_T)rtDW.Merge);\r\n\r\n  /* Gain: '<S4>/Gain2' incorporates:\r\n   *  Inport: '<Root>/ib'\r\n   *  Inport: '<Root>/ic'\r\n   *  Sum: '<S4>/Add1'\r\n   */\r\n  rtb_Gain2_n = (rtU.ib - rtU.ic) * 0.577350259F;\r\n\r\n  /* Trigonometry: '<S1>/SinCos1' incorporates:\r\n   *  DataTypeConversion: '<S1>/Data Type Conversion3'\r\n   */\r\n  rtb_A = sinf((real32_T)rtDW.Merge);\r\n\r\n  /* Sum: '<S5>/Sum1' incorporates:\r\n   *  Constant: '<S5>/Constant5'\r\n   *  Product: '<S7>/Product'\r\n   *  Product: '<S7>/Product1'\r\n   *  Sum: '<S7>/Subtract'\r\n   */\r\n  rtb_DiscreteTimeIntegrator = 0.0 - (rtb_Add2_c * rtb_SinCos2 + rtb_Gain2_n *\r\n    rtb_A);\r\n\r\n  /* Sum: '<S107>/Sum' incorporates:\r\n   *  Constant: '<S5>/Constant4'\r\n   *  DiscreteIntegrator: '<S98>/Integrator'\r\n   *  Product: '<S103>/PProd Out'\r\n   */\r\n  rtb_SignPreSat = rtb_DiscreteTimeIntegrator * 0.17 + rtDW.Integrator_DSTATE;\r\n\r\n  /* Saturate: '<S105>/Saturation' */\r\n  if (rtb_SignPreSat > 13.856406460551019) {\r\n    rtb_Saturation = 13.856406460551019;\r\n  } else if (rtb_SignPreSat < -13.856406460551019) {\r\n    rtb_Saturation = -13.856406460551019;\r\n  } else {\r\n    rtb_Saturation = rtb_SignPreSat;\r\n  }\r\n\r\n  /* End of Saturate: '<S105>/Saturation' */\r\n\r\n  /* Sum: '<S5>/Sum' incorporates:\r\n   *  Product: '<S7>/Product2'\r\n   *  Product: '<S7>/Product3'\r\n   *  Sum: '<S7>/Subtract1'\r\n   */\r\n  rtb_IProdOut_a = rtDW.Merge1 - (rtb_Gain2_n * rtb_SinCos2 - rtb_Add2_c * rtb_A);\r\n\r\n  /* Sum: '<S57>/Sum' incorporates:\r\n   *  Constant: '<S5>/Constant2'\r\n   *  DiscreteIntegrator: '<S48>/Integrator'\r\n   *  Product: '<S53>/PProd Out'\r\n   */\r\n  rtb_SignPreSat_e = rtb_IProdOut_a * 0.17 + rtDW.Integrator_DSTATE_l;\r\n\r\n  /* Saturate: '<S55>/Saturation' */\r\n  if (rtb_SignPreSat_e > 13.856406460551019) {\r\n    rtb_Divide4 = 13.856406460551019;\r\n  } else if (rtb_SignPreSat_e < -13.856406460551019) {\r\n    rtb_Divide4 = -13.856406460551019;\r\n  } else {\r\n    rtb_Divide4 = rtb_SignPreSat_e;\r\n  }\r\n\r\n  /* End of Saturate: '<S55>/Saturation' */\r\n\r\n  /* Sum: '<S2>/Subtract' incorporates:\r\n   *  Product: '<S2>/Product'\r\n   *  Product: '<S2>/Product1'\r\n   */\r\n  rtb_Subtract = rtb_Saturation * rtb_A + rtb_Divide4 * rtb_SinCos2;\r\n\r\n  /* Sum: '<S2>/Subtract1' incorporates:\r\n   *  Product: '<S2>/Product2'\r\n   *  Product: '<S2>/Product3'\r\n   */\r\n  rtb_T6 = rtb_Saturation * rtb_SinCos2 - rtb_Divide4 * rtb_A;\r\n\r\n  /* Gain: '<S89>/ZeroGain' */\r\n  rtb_Saturation = 0.0 * rtb_SignPreSat;\r\n\r\n  /* DeadZone: '<S91>/DeadZone' */\r\n  if (rtb_SignPreSat > 13.856406460551019) {\r\n    rtb_SignPreSat -= 13.856406460551019;\r\n  } else if (rtb_SignPreSat >= -13.856406460551019) {\r\n    rtb_SignPreSat = 0.0;\r\n  } else {\r\n    rtb_SignPreSat -= -13.856406460551019;\r\n  }\r\n\r\n  /* End of DeadZone: '<S91>/DeadZone' */\r\n\r\n  /* Product: '<S95>/IProd Out' incorporates:\r\n   *  Constant: '<S5>/Constant3'\r\n   */\r\n  rtb_DiscreteTimeIntegrator *= 35.0;\r\n\r\n  /* Gain: '<S39>/ZeroGain' */\r\n  rtb_ZeroGain_f = 0.0 * rtb_SignPreSat_e;\r\n\r\n  /* DeadZone: '<S41>/DeadZone' */\r\n  if (rtb_SignPreSat_e > 13.856406460551019) {\r\n    rtb_SignPreSat_e -= 13.856406460551019;\r\n  } else if (rtb_SignPreSat_e >= -13.856406460551019) {\r\n    rtb_SignPreSat_e = 0.0;\r\n  } else {\r\n    rtb_SignPreSat_e -= -13.856406460551019;\r\n  }\r\n\r\n  /* End of DeadZone: '<S41>/DeadZone' */\r\n\r\n  /* Product: '<S45>/IProd Out' incorporates:\r\n   *  Constant: '<S5>/Constant'\r\n   */\r\n  rtb_IProdOut_a *= 35.0;\r\n\r\n  /* Gain: '<S115>/Gain1' incorporates:\r\n   *  Gain: '<S116>/Gain2'\r\n   */\r\n  rtb_T6 *= 0.8660254037844386;\r\n\r\n  /* Gain: '<S115>/Gain2' incorporates:\r\n   *  Gain: '<S116>/Gain1'\r\n   */\r\n  rtb_Divide4_tmp = 0.5 * rtb_Subtract;\r\n\r\n  /* Sum: '<S115>/Add' incorporates:\r\n   *  Gain: '<S115>/Gain1'\r\n   *  Gain: '<S115>/Gain2'\r\n   *  Gain: '<S115>/Gain3'\r\n   *  Gain: '<S115>/Gain4'\r\n   *  Gain: '<S115>/Gain5'\r\n   *  Sum: '<S115>/Sum'\r\n   *  Sum: '<S115>/Sum1'\r\n   *  Switch: '<S115>/Switch'\r\n   *  Switch: '<S115>/Switch1'\r\n   *  Switch: '<S115>/Switch2'\r\n   */\r\n  rtb_Add2_c = (real32_T)((((-rtb_T6 - rtb_Divide4_tmp > 0.0) << 2) + ((rtb_T6 -\r\n    rtb_Divide4_tmp > 0.0) << 1)) + (rtb_Subtract > 0.0));\r\n\r\n  /* Product: '<S116>/Divide' incorporates:\r\n   *  Inport: '<Root>/u_bus'\r\n   */\r\n  rtb_Divide4 = 1.0 / rtU.u_bus * 1.7320508075688772;\r\n\r\n  /* MultiPortSwitch: '<S116>/Multiport Switch' incorporates:\r\n   *  Gain: '<S116>/Gain3'\r\n   *  Gain: '<S116>/Gain4'\r\n   *  Gain: '<S116>/Gain5'\r\n   *  Gain: '<S116>/Gain6'\r\n   *  Product: '<S116>/Divide1'\r\n   *  Product: '<S116>/Divide2'\r\n   *  Product: '<S116>/Divide3'\r\n   *  Sum: '<S116>/Sum'\r\n   *  Sum: '<S116>/Sum1'\r\n   */\r\n  switch ((int32_T)rtb_Add2_c) {\r\n   case 1:\r\n    rtb_T4 = (-rtb_T6 + rtb_Divide4_tmp) * rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S116>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S116>/Gain3'\r\n     *  Product: '<S116>/Divide2'\r\n     *  Product: '<S116>/Divide3'\r\n     *  Sum: '<S116>/Sum'\r\n     *  Sum: '<S116>/Sum1'\r\n     */\r\n    rtb_T6 = (rtb_T6 + rtb_Divide4_tmp) * rtb_Divide4;\r\n    break;\r\n\r\n   case 2:\r\n    rtb_T4 = (rtb_T6 + rtb_Divide4_tmp) * rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S116>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S116>/Gain6'\r\n     *  Product: '<S116>/Divide1'\r\n     *  Product: '<S116>/Divide2'\r\n     *  Sum: '<S116>/Sum'\r\n     */\r\n    rtb_T6 = -(rtb_Subtract * rtb_Divide4);\r\n    break;\r\n\r\n   case 3:\r\n    rtb_T4 = -((-rtb_T6 + rtb_Divide4_tmp) * rtb_Divide4);\r\n\r\n    /* MultiPortSwitch: '<S116>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S116>/Gain3'\r\n     *  Gain: '<S116>/Gain4'\r\n     *  Product: '<S116>/Divide1'\r\n     *  Product: '<S116>/Divide3'\r\n     *  Sum: '<S116>/Sum1'\r\n     */\r\n    rtb_T6 = rtb_Subtract * rtb_Divide4;\r\n    break;\r\n\r\n   case 4:\r\n    rtb_T4 = -(rtb_Subtract * rtb_Divide4);\r\n\r\n    /* MultiPortSwitch: '<S116>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S116>/Gain3'\r\n     *  Gain: '<S116>/Gain6'\r\n     *  Product: '<S116>/Divide1'\r\n     *  Product: '<S116>/Divide3'\r\n     *  Sum: '<S116>/Sum1'\r\n     */\r\n    rtb_T6 = (-rtb_T6 + rtb_Divide4_tmp) * rtb_Divide4;\r\n    break;\r\n\r\n   case 5:\r\n    rtb_T4 = rtb_Subtract * rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S116>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S116>/Gain5'\r\n     *  Product: '<S116>/Divide1'\r\n     *  Product: '<S116>/Divide2'\r\n     *  Sum: '<S116>/Sum'\r\n     */\r\n    rtb_T6 = -((rtb_T6 + rtb_Divide4_tmp) * rtb_Divide4);\r\n    break;\r\n\r\n   default:\r\n    rtb_T4 = -((rtb_T6 + rtb_Divide4_tmp) * rtb_Divide4);\r\n\r\n    /* MultiPortSwitch: '<S116>/Multiport Switch1' incorporates:\r\n     *  Gain: '<S116>/Gain3'\r\n     *  Gain: '<S116>/Gain4'\r\n     *  Gain: '<S116>/Gain5'\r\n     *  Product: '<S116>/Divide2'\r\n     *  Product: '<S116>/Divide3'\r\n     *  Sum: '<S116>/Sum'\r\n     *  Sum: '<S116>/Sum1'\r\n     */\r\n    rtb_T6 = -((-rtb_T6 + rtb_Divide4_tmp) * rtb_Divide4);\r\n    break;\r\n  }\r\n\r\n  /* End of MultiPortSwitch: '<S116>/Multiport Switch' */\r\n\r\n  /* Product: '<S116>/Divide4' incorporates:\r\n   *  Sum: '<S116>/Subtract'\r\n   */\r\n  rtb_Divide4 = 1.0 / (rtb_T4 + rtb_T6);\r\n\r\n  /* Switch: '<S116>/Switch' incorporates:\r\n   *  Constant: '<S1>/Constant1'\r\n   *  Product: '<S116>/Divide5'\r\n   *  Product: '<S116>/Divide6'\r\n   *  Sum: '<S116>/Add'\r\n   *  Switch: '<S116>/Switch1'\r\n   */\r\n  if ((rtb_T4 - 1.0) + rtb_T6 > 0.0) {\r\n    rtb_T4 *= rtb_Divide4;\r\n    rtb_T6 *= rtb_Divide4;\r\n  }\r\n\r\n  /* End of Switch: '<S116>/Switch' */\r\n\r\n  /* Gain: '<S117>/Gain' incorporates:\r\n   *  Constant: '<S1>/Constant1'\r\n   *  Sum: '<S117>/Add'\r\n   */\r\n  rtb_Divide4 = ((1.0 - rtb_T4) - rtb_T6) * 0.25;\r\n\r\n  /* Sum: '<S117>/Add1' incorporates:\r\n   *  Gain: '<S117>/Gain1'\r\n   */\r\n  rtb_Subtract = 0.5 * rtb_T4 + rtb_Divide4;\r\n\r\n  /* Sum: '<S117>/Add2' incorporates:\r\n   *  Gain: '<S117>/Gain2'\r\n   */\r\n  rtb_Divide4_tmp = 0.5 * rtb_T6 + rtb_Subtract;\r\n\r\n  /* MultiPortSwitch: '<S117>/Tcm1 ' incorporates:\r\n   *  Gain: '<S117>/Gain2'\r\n   *  Sum: '<S117>/Add2'\r\n   */\r\n  switch ((int32_T)rtb_Add2_c) {\r\n   case 1:\r\n    rtb_T6 = rtb_Subtract;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm2' */\r\n    rtb_T4 = rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm3' incorporates:\r\n     *  Sum: '<S117>/Add2'\r\n     */\r\n    rtb_Divide4 = rtb_Divide4_tmp;\r\n    break;\r\n\r\n   case 2:\r\n    rtb_T6 = rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm2' incorporates:\r\n     *  Sum: '<S117>/Add2'\r\n     */\r\n    rtb_T4 = rtb_Divide4_tmp;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm3' */\r\n    rtb_Divide4 = rtb_Subtract;\r\n    break;\r\n\r\n   case 3:\r\n    rtb_T6 = rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm2' */\r\n    rtb_T4 = rtb_Subtract;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm3' incorporates:\r\n     *  Sum: '<S117>/Add2'\r\n     */\r\n    rtb_Divide4 = rtb_Divide4_tmp;\r\n    break;\r\n\r\n   case 4:\r\n    rtb_T6 = 0.5 * rtb_T6 + rtb_Subtract;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm2' incorporates:\r\n     *  Gain: '<S117>/Gain2'\r\n     *  Sum: '<S117>/Add2'\r\n     */\r\n    rtb_T4 = rtb_Subtract;\r\n    break;\r\n\r\n   case 5:\r\n    rtb_T6 = 0.5 * rtb_T6 + rtb_Subtract;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm2' incorporates:\r\n     *  Gain: '<S117>/Gain2'\r\n     *  Sum: '<S117>/Add2'\r\n     */\r\n    rtb_T4 = rtb_Divide4;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm3' */\r\n    rtb_Divide4 = rtb_Subtract;\r\n    break;\r\n\r\n   default:\r\n    rtb_T6 = rtb_Subtract;\r\n\r\n    /* MultiPortSwitch: '<S117>/Tcm2' incorporates:\r\n     *  Sum: '<S117>/Add2'\r\n     */\r\n    rtb_T4 = rtb_Divide4_tmp;\r\n    break;\r\n  }\r\n\r\n  /* End of MultiPortSwitch: '<S117>/Tcm1 ' */\r\n\r\n  /* Signum: '<S89>/SignPreSat' */\r\n  if (rtb_SignPreSat < 0.0) {\r\n    rtb_Subtract = -1.0;\r\n  } else if (rtb_SignPreSat > 0.0) {\r\n    rtb_Subtract = 1.0;\r\n  } else if (rtb_SignPreSat == 0.0) {\r\n    rtb_Subtract = 0.0;\r\n  } else {\r\n    rtb_Subtract = (rtNaN);\r\n  }\r\n\r\n  /* End of Signum: '<S89>/SignPreSat' */\r\n\r\n  /* Signum: '<S89>/SignPreIntegrator' */\r\n  if (rtb_DiscreteTimeIntegrator < 0.0) {\r\n    rtb_Divide4_tmp = -1.0;\r\n  } else if (rtb_DiscreteTimeIntegrator > 0.0) {\r\n    rtb_Divide4_tmp = 1.0;\r\n  } else if (rtb_DiscreteTimeIntegrator == 0.0) {\r\n    rtb_Divide4_tmp = 0.0;\r\n  } else {\r\n    rtb_Divide4_tmp = (rtNaN);\r\n  }\r\n\r\n  /* End of Signum: '<S89>/SignPreIntegrator' */\r\n\r\n  /* Switch: '<S89>/Switch' incorporates:\r\n   *  Constant: '<S89>/Constant1'\r\n   *  DataTypeConversion: '<S89>/DataTypeConv1'\r\n   *  DataTypeConversion: '<S89>/DataTypeConv2'\r\n   *  Logic: '<S89>/AND3'\r\n   *  RelationalOperator: '<S89>/Equal1'\r\n   *  RelationalOperator: '<S89>/NotEqual'\r\n   */\r\n  if ((rtb_Saturation != rtb_SignPreSat) && ((int8_T)rtb_Subtract == (int8_T)\r\n       rtb_Divide4_tmp)) {\r\n    rtb_DiscreteTimeIntegrator = 0.0;\r\n  }\r\n\r\n  /* End of Switch: '<S89>/Switch' */\r\n\r\n  /* Update for DiscreteIntegrator: '<S98>/Integrator' */\r\n  rtDW.Integrator_DSTATE += 0.0001 * rtb_DiscreteTimeIntegrator;\r\n\r\n  /* Signum: '<S39>/SignPreSat' */\r\n  if (rtb_SignPreSat_e < 0.0) {\r\n    rtb_DiscreteTimeIntegrator = -1.0;\r\n  } else if (rtb_SignPreSat_e > 0.0) {\r\n    rtb_DiscreteTimeIntegrator = 1.0;\r\n  } else if (rtb_SignPreSat_e == 0.0) {\r\n    rtb_DiscreteTimeIntegrator = 0.0;\r\n  } else {\r\n    rtb_DiscreteTimeIntegrator = (rtNaN);\r\n  }\r\n\r\n  /* End of Signum: '<S39>/SignPreSat' */\r\n\r\n  /* Signum: '<S39>/SignPreIntegrator' */\r\n  if (rtb_IProdOut_a < 0.0) {\r\n    rtb_SignPreSat = -1.0;\r\n  } else if (rtb_IProdOut_a > 0.0) {\r\n    rtb_SignPreSat = 1.0;\r\n  } else if (rtb_IProdOut_a == 0.0) {\r\n    rtb_SignPreSat = 0.0;\r\n  } else {\r\n    rtb_SignPreSat = (rtNaN);\r\n  }\r\n\r\n  /* End of Signum: '<S39>/SignPreIntegrator' */\r\n\r\n  /* Switch: '<S39>/Switch' incorporates:\r\n   *  Constant: '<S39>/Constant1'\r\n   *  DataTypeConversion: '<S39>/DataTypeConv1'\r\n   *  DataTypeConversion: '<S39>/DataTypeConv2'\r\n   *  Logic: '<S39>/AND3'\r\n   *  RelationalOperator: '<S39>/Equal1'\r\n   *  RelationalOperator: '<S39>/NotEqual'\r\n   */\r\n  if ((rtb_ZeroGain_f != rtb_SignPreSat_e) && ((int8_T)\r\n       rtb_DiscreteTimeIntegrator == (int8_T)rtb_SignPreSat)) {\r\n    rtb_IProdOut_a = 0.0;\r\n  }\r\n\r\n  /* End of Switch: '<S39>/Switch' */\r\n\r\n  /* Update for DiscreteIntegrator: '<S48>/Integrator' */\r\n  rtDW.Integrator_DSTATE_l += 0.0001 * rtb_IProdOut_a;\r\n\r\n  /* Outport: '<Root>/DutyOut' incorporates:\r\n   *  Constant: '<S1>/Constant1'\r\n   *  Gain: '<S6>/Gain'\r\n   *  Sum: '<S6>/Add'\r\n   *  Sum: '<S6>/Add1'\r\n   *  Sum: '<S6>/Add2'\r\n   */\r\n  rtY.DutyOut[0] = 1.0 - 2.0 * rtb_T6;\r\n  rtY.DutyOut[1] = 1.0 - 2.0 * rtb_T4;\r\n  rtY.DutyOut[2] = 1.0 - 2.0 * rtb_Divide4;\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/IF' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid IF0_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"IF0.h","type":"header","group":"model","path":"S:\\STM32SSC\\STM32\\STM32SSC_Engine\\Mode\\PMSM\\currloop\\IF0_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: IF0.h\r\n *\r\n * Code generated for Simulink model 'IF0'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon Dec 18 15:46:35 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_IF0_h_\r\n#define RTW_HEADER_IF0_h_\r\n#include <stddef.h>\r\n#include <float.h>\r\n#include <math.h>\r\n#ifndef IF0_COMMON_INCLUDES_\r\n#define IF0_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* IF0_COMMON_INCLUDES_ */\r\n\r\n/* Model Code Variants */\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T Merge;                        /* '<S1>/Merge' */\r\n  real_T Merge1;                       /* '<S1>/Merge1' */\r\n  real_T Motor_State;                  /* '<S1>/Chart' */\r\n  real_T Integrator_DSTATE;            /* '<S98>/Integrator' */\r\n  real_T Integrator_DSTATE_l;          /* '<S48>/Integrator' */\r\n  real_T DiscreteTimeIntegrator1_DSTATE;/* '<S12>/Discrete-Time Integrator1' */\r\n  real_T DiscreteTimeIntegrator_DSTATE;/* '<S11>/Discrete-Time Integrator' */\r\n  real_T DiscreteTimeIntegrator1_DSTAT_h;/* '<S11>/Discrete-Time Integrator1' */\r\n  uint16_T temporalCounter_i1;         /* '<S1>/Chart' */\r\n  uint8_T is_active_c3_IF0;            /* '<S1>/Chart' */\r\n  uint8_T is_c3_IF0;                   /* '<S1>/Chart' */\r\n} DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real32_T ia;                         /* '<Root>/ia' */\r\n  real32_T ib;                         /* '<Root>/ib' */\r\n  real32_T ic;                         /* '<Root>/ic' */\r\n  real_T u_bus;                        /* '<Root>/u_bus' */\r\n  real_T Motor_OnOff;                  /* '<Root>/Motor_OnOff' */\r\n} ExtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T DutyOut[3];                   /* '<Root>/DutyOut' */\r\n} ExtY;\r\n\r\n/* Type definition for custom storage class: Struct */\r\ntypedef struct Motor_tag {\r\n  real32_T Pn;                         /* Referenced by:\r\n                                        * '<S11>/Gain1'\r\n                                        * '<S12>/Gain1'\r\n                                        */\r\n} Motor_type;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY rtY;\r\n\r\n/* Model entry point functions */\r\nextern void IF0_initialize(void);\r\nextern void IF0_step(void);\r\n\r\n/* Exported data declaration */\r\n\r\n/* Declaration for custom storage class: Struct */\r\nextern Motor_type Motor;\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S5>/Scope' : Unused code path elimination\r\n * Block '<S115>/Scope' : Unused code path elimination\r\n * Block '<S115>/Scope1' : Unused code path elimination\r\n * Block '<S116>/Scope' : Unused code path elimination\r\n * Block '<S115>/Gain' : Eliminated nontunable gain of 1\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('currloop/IF')    - opens subsystem currloop/IF\r\n * hilite_system('currloop/IF/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'currloop'\r\n * '<S1>'   : 'currloop/IF'\r\n * '<S2>'   : 'currloop/IF/AntiPark'\r\n * '<S3>'   : 'currloop/IF/Chart'\r\n * '<S4>'   : 'currloop/IF/Clark'\r\n * '<S5>'   : 'currloop/IF/Curr_PID'\r\n * '<S6>'   : 'currloop/IF/PWMOut'\r\n * '<S7>'   : 'currloop/IF/Park'\r\n * '<S8>'   : 'currloop/IF/SVPWM'\r\n * '<S9>'   : 'currloop/IF/Switch Case Action Subsystem'\r\n * '<S10>'  : 'currloop/IF/Switch Case Action Subsystem1'\r\n * '<S11>'  : 'currloop/IF/Switch Case Action Subsystem2'\r\n * '<S12>'  : 'currloop/IF/Switch Case Action Subsystem3'\r\n * '<S13>'  : 'currloop/IF/Curr_PID/Discrete PID Controller'\r\n * '<S14>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1'\r\n * '<S15>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Anti-windup'\r\n * '<S16>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/D Gain'\r\n * '<S17>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Filter'\r\n * '<S18>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Filter ICs'\r\n * '<S19>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/I Gain'\r\n * '<S20>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Ideal P Gain'\r\n * '<S21>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Ideal P Gain Fdbk'\r\n * '<S22>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Integrator'\r\n * '<S23>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Integrator ICs'\r\n * '<S24>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/N Copy'\r\n * '<S25>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/N Gain'\r\n * '<S26>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/P Copy'\r\n * '<S27>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Parallel P Gain'\r\n * '<S28>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Reset Signal'\r\n * '<S29>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Saturation'\r\n * '<S30>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Saturation Fdbk'\r\n * '<S31>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Sum'\r\n * '<S32>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Sum Fdbk'\r\n * '<S33>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Tracking Mode'\r\n * '<S34>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Tracking Mode Sum'\r\n * '<S35>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Tsamp - Integral'\r\n * '<S36>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Tsamp - Ngain'\r\n * '<S37>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/postSat Signal'\r\n * '<S38>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/preSat Signal'\r\n * '<S39>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel'\r\n * '<S40>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S41>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S42>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/D Gain/Disabled'\r\n * '<S43>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Filter/Disabled'\r\n * '<S44>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Filter ICs/Disabled'\r\n * '<S45>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/I Gain/External Parameters'\r\n * '<S46>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Ideal P Gain/Passthrough'\r\n * '<S47>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Ideal P Gain Fdbk/Disabled'\r\n * '<S48>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Integrator/Discrete'\r\n * '<S49>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Integrator ICs/Internal IC'\r\n * '<S50>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/N Copy/Disabled wSignal Specification'\r\n * '<S51>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/N Gain/Disabled'\r\n * '<S52>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/P Copy/Disabled'\r\n * '<S53>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Parallel P Gain/External Parameters'\r\n * '<S54>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Reset Signal/Disabled'\r\n * '<S55>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Saturation/Enabled'\r\n * '<S56>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Saturation Fdbk/Disabled'\r\n * '<S57>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Sum/Sum_PI'\r\n * '<S58>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Sum Fdbk/Disabled'\r\n * '<S59>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Tracking Mode/Disabled'\r\n * '<S60>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Tracking Mode Sum/Passthrough'\r\n * '<S61>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Tsamp - Integral/Passthrough'\r\n * '<S62>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/Tsamp - Ngain/Passthrough'\r\n * '<S63>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/postSat Signal/Forward_Path'\r\n * '<S64>'  : 'currloop/IF/Curr_PID/Discrete PID Controller/preSat Signal/Forward_Path'\r\n * '<S65>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Anti-windup'\r\n * '<S66>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/D Gain'\r\n * '<S67>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Filter'\r\n * '<S68>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Filter ICs'\r\n * '<S69>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/I Gain'\r\n * '<S70>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Ideal P Gain'\r\n * '<S71>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Ideal P Gain Fdbk'\r\n * '<S72>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Integrator'\r\n * '<S73>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Integrator ICs'\r\n * '<S74>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/N Copy'\r\n * '<S75>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/N Gain'\r\n * '<S76>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/P Copy'\r\n * '<S77>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Parallel P Gain'\r\n * '<S78>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Reset Signal'\r\n * '<S79>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Saturation'\r\n * '<S80>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Saturation Fdbk'\r\n * '<S81>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Sum'\r\n * '<S82>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Sum Fdbk'\r\n * '<S83>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Tracking Mode'\r\n * '<S84>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Tracking Mode Sum'\r\n * '<S85>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Tsamp - Integral'\r\n * '<S86>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Tsamp - Ngain'\r\n * '<S87>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/postSat Signal'\r\n * '<S88>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/preSat Signal'\r\n * '<S89>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Anti-windup/Disc. Clamping Parallel'\r\n * '<S90>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S91>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S92>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/D Gain/Disabled'\r\n * '<S93>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Filter/Disabled'\r\n * '<S94>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Filter ICs/Disabled'\r\n * '<S95>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/I Gain/External Parameters'\r\n * '<S96>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Ideal P Gain/Passthrough'\r\n * '<S97>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Ideal P Gain Fdbk/Disabled'\r\n * '<S98>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Integrator/Discrete'\r\n * '<S99>'  : 'currloop/IF/Curr_PID/Discrete PID Controller1/Integrator ICs/Internal IC'\r\n * '<S100>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/N Copy/Disabled wSignal Specification'\r\n * '<S101>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/N Gain/Disabled'\r\n * '<S102>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/P Copy/Disabled'\r\n * '<S103>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Parallel P Gain/External Parameters'\r\n * '<S104>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Reset Signal/Disabled'\r\n * '<S105>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Saturation/Enabled'\r\n * '<S106>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Saturation Fdbk/Disabled'\r\n * '<S107>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Sum/Sum_PI'\r\n * '<S108>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Sum Fdbk/Disabled'\r\n * '<S109>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Tracking Mode/Disabled'\r\n * '<S110>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Tracking Mode Sum/Passthrough'\r\n * '<S111>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Tsamp - Integral/Passthrough'\r\n * '<S112>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/Tsamp - Ngain/Passthrough'\r\n * '<S113>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/postSat Signal/Forward_Path'\r\n * '<S114>' : 'currloop/IF/Curr_PID/Discrete PID Controller1/preSat Signal/Forward_Path'\r\n * '<S115>' : 'currloop/IF/SVPWM/N'\r\n * '<S116>' : 'currloop/IF/SVPWM/t4_t6'\r\n * '<S117>' : 'currloop/IF/SVPWM/t_abc'\r\n */\r\n#endif                                 /* RTW_HEADER_IF0_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"S:\\STM32SSC\\STM32\\STM32SSC_Engine\\Mode\\PMSM\\currloop\\IF0_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'IF0'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon Dec 18 15:46:35 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex-M\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};